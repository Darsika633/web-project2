import mongoose from 'mongoose';

const orderItemSchema = new mongoose.Schema({
  product: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Product',
    required: [true, 'Product is required']
  },
  variant: {
    size: {
      type: String,
      required: [true, 'Size is required']
    },
    color: {
      name: {
        type: String,
        required: [true, 'Color name is required']
      },
      hex: String
    },
    sku: {
      type: String,
      required: [true, 'SKU is required']
    }
  },
  quantity: {
    type: Number,
    required: [true, 'Quantity is required'],
    min: [1, 'Quantity must be at least 1']
  },
  unitPrice: {
    type: Number,
    required: [true, 'Unit price is required'],
    min: [0, 'Unit price cannot be negative']
  },
  totalPrice: {
    type: Number,
    required: [true, 'Total price is required'],
    min: [0, 'Total price cannot be negative']
  }
}, {
  timestamps: false
});

const orderSchema = new mongoose.Schema({
  orderNumber: {
    type: String,
    unique: true,
    required: false // Will be generated by pre-save hook
  },
  customer: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Customer is required']
  },
  deliveryPerson: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    default: null
  },
  assignedAt: {
    type: Date,
    default: null
  },
  status: {
    type: String,
    enum: ['pending', 'confirmed', 'shipped', 'assigned', 'out_for_delivery', 'delivered', 'completed', 'cancelled'],
    default: 'pending'
  },
  items: [orderItemSchema],
  
  // Pricing
  subtotal: {
    type: Number,
    required: [true, 'Subtotal is required'],
    min: [0, 'Subtotal cannot be negative']
  },
  deliveryCost: {
    type: Number,
    default: 400, // Standard: 400 LKR, Express: 1000 LKR
    min: [0, 'Delivery cost cannot be negative']
  },
  discount: {
    code: {
      type: String,
      trim: true
    },
    amount: {
      type: Number,
      default: 0,
      min: [0, 'Discount amount cannot be negative']
    },
    type: {
      type: String,
      enum: ['percentage', 'fixed'],
      default: 'fixed'
    }
  },
  totalAmount: {
    type: Number,
    required: [true, 'Total amount is required'],
    min: [0, 'Total amount cannot be negative']
  },
  
  // Customer Details
  deliveryAddress: {
    street: {
      type: String,
      required: [true, 'Delivery street address is required'],
      trim: true
    },
    city: {
      type: String,
      required: [true, 'Delivery city is required'],
      trim: true
    },
    state: {
      type: String,
      required: [true, 'Delivery state is required'],
      trim: true
    },
    zipCode: {
      type: String,
      required: [true, 'Delivery zip code is required'],
      trim: true
    },
    country: {
      type: String,
      required: [true, 'Delivery country is required'],
      trim: true,
      default: 'Sri Lanka'
    },
    phone: {
      type: String,
      required: [true, 'Delivery phone is required'],
      trim: true
    }
  },
  billingAddress: {
    street: {
      type: String,
      required: [true, 'Billing street address is required'],
      trim: true
    },
    city: {
      type: String,
      required: [true, 'Billing city is required'],
      trim: true
    },
    state: {
      type: String,
      required: [true, 'Billing state is required'],
      trim: true
    },
    zipCode: {
      type: String,
      required: [true, 'Billing zip code is required'],
      trim: true
    },
    country: {
      type: String,
      required: [true, 'Billing country is required'],
      trim: true,
      default: 'Sri Lanka'
    }
  },
  
  // Payment
  payment: {
    method: {
      type: String,
      enum: ['cash_on_delivery', 'credit_card', 'debit_card', 'bank_transfer', 'digital_wallet'],
      required: [true, 'Payment method is required']
    },
    status: {
      type: String,
      enum: ['pending', 'paid', 'failed', 'refunded', 'partially_refunded'],
      default: 'pending'
    },
    transactionId: {
      type: String,
      trim: true
    },
    paidAt: {
      type: Date
    }
  },
  
  // Reference to Payment model for COD orders
  paymentRecord: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Payment',
    default: null
  },
  
  // Shipping
  shipping: {
    method: {
      type: String,
      enum: ['standard', 'express'],
      default: 'standard',
      description: 'standard: 3 working days (400 LKR), express: within 1 day (1000 LKR)'
    },
    trackingNumber: {
      type: String,
      trim: true
    },
    estimatedDeliveryDate: {
      type: Date
    },
    actualDeliveryDate: {
      type: Date
    },
    deliveryPartner: {
      type: String,
      trim: true
    },
    deliveryPersonEstimatedTime: {
      type: Date
    },
    deliveryNotes: {
      type: String,
      trim: true,
      maxlength: [500, 'Delivery notes cannot exceed 500 characters']
    }
  },
  
  // Delivery Person Rating
  deliveryRating: {
    rating: {
      type: Number,
      min: [1, 'Rating must be at least 1'],
      max: [5, 'Rating cannot exceed 5'],
      validate: {
        validator: Number.isInteger,
        message: 'Rating must be a whole number'
      }
    },
    feedback: {
      type: String,
      trim: true,
      maxlength: [500, 'Delivery feedback cannot exceed 500 characters']
    },
    ratedAt: {
      type: Date
    }
  },
  
  // Status History
  statusHistory: [{
    status: {
      type: String,
      required: true
    },
    changedAt: {
      type: Date,
      default: Date.now
    },
    changedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    notes: {
      type: String,
      trim: true
    }
  }],
  
  // Additional Info
  notes: {
    type: String,
    trim: true,
    maxlength: [500, 'Notes cannot exceed 500 characters']
  },
  currency: {
    type: String,
    default: 'LKR',
    enum: ['LKR', 'USD', 'EUR', 'GBP']
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Virtual for order status display
orderSchema.virtual('statusDisplay').get(function() {
  const statusMap = {
    'pending': 'Pending',
    'confirmed': 'Confirmed',
    'shipped': 'Shipped',
    'assigned': 'Assigned to Delivery Person',
    'out_for_delivery': 'Out for Delivery',
    'delivered': 'Delivered',
    'completed': 'Completed',
    'cancelled': 'Cancelled'
  };
  return statusMap[this.status] || this.status;
});

// Virtual for payment status display
orderSchema.virtual('paymentStatusDisplay').get(function() {
  const statusMap = {
    'pending': 'Pending',
    'paid': 'Paid',
    'failed': 'Failed',
    'refunded': 'Refunded',
    'partially_refunded': 'Partially Refunded'
  };
  return statusMap[this.payment.status] || this.payment.status;
});

// Indexes for better performance
// Note: orderNumber index is already created by unique: true in schema
orderSchema.index({ customer: 1 });
orderSchema.index({ status: 1 });
orderSchema.index({ deliveryPerson: 1 });
orderSchema.index({ 'payment.status': 1 });
orderSchema.index({ createdAt: -1 });
orderSchema.index({ 'deliveryAddress.city': 1 });
orderSchema.index({ 'deliveryAddress.state': 1 });

// Pre-save middleware to generate order number
orderSchema.pre('save', async function(next) {
  try {
    // Generate order number for new orders
    if (this.isNew && !this.orderNumber) {
      let orderNumber;
      let isUnique = false;
      let attempts = 0;
      const maxAttempts = 10;
      
      // Generate unique order number with retry logic
      while (!isUnique && attempts < maxAttempts) {
        const count = await this.constructor.countDocuments();
        orderNumber = `TB${String(count + 1 + attempts).padStart(6, '0')}`;
        
        // Check if this order number already exists
        const existingOrder = await this.constructor.findOne({ orderNumber });
        if (!existingOrder) {
          isUnique = true;
        }
        attempts++;
      }
      
      if (!isUnique) {
        // Fallback to timestamp-based order number
        orderNumber = `TB${Date.now().toString().slice(-6)}`;
      }
      
      this.orderNumber = orderNumber;
      console.log(`Generated order number: ${orderNumber}`);
    }
    
    // Add to status history when status changes
    if (this.isModified('status') && !this.isNew) {
      this.statusHistory.push({
        status: this.status,
        changedAt: new Date(),
        notes: `Status changed to ${this.status}`
      });
    }
    
    next();
  } catch (error) {
    console.error('Error in pre-save hook:', error);
    next(error);
  }
});

// Static method to get orders with filters
orderSchema.statics.getFilteredOrders = async function(filters = {}) {
  const {
    status,
    paymentStatus,
    customer,
    deliveryPerson,
    dateFrom,
    dateTo,
    search,
    sortBy = 'createdAt',
    sortOrder = 'desc',
    page = 1,
    limit = 20
  } = filters;

  const query = {};

  // Status filter
  if (status) {
    if (Array.isArray(status)) {
      query.status = { $in: status };
    } else {
      query.status = status;
    }
  }

  // Payment status filter
  if (paymentStatus) {
    if (Array.isArray(paymentStatus)) {
      query['payment.status'] = { $in: paymentStatus };
    } else {
      query['payment.status'] = paymentStatus;
    }
  }

  // Customer filter
  if (customer) {
    query.customer = customer;
  }

  // Delivery person filter
  if (deliveryPerson) {
    query.deliveryPerson = deliveryPerson;
  }

  // Date range filter
  if (dateFrom || dateTo) {
    query.createdAt = {};
    if (dateFrom) query.createdAt.$gte = new Date(dateFrom);
    if (dateTo) query.createdAt.$lte = new Date(dateTo);
  }

  // Search filter
  if (search) {
    query.$or = [
      { orderNumber: new RegExp(search, 'i') },
      { 'customer.email': new RegExp(search, 'i') },
      { 'deliveryAddress.phone': new RegExp(search, 'i') }
    ];
  }

  // Sort options
  const sortOptions = {};
  sortOptions[sortBy] = sortOrder === 'desc' ? -1 : 1;

  // Pagination
  const skip = (page - 1) * limit;

  const orders = await this.find(query)
    .populate('customer', 'firstName lastName email phone')
    .populate('deliveryPerson', 'firstName lastName email phone')
    .populate('items.product', 'name brand images')
    .sort(sortOptions)
    .skip(skip)
    .limit(limit)
    .lean();

  const total = await this.countDocuments(query);

  return {
    orders,
    pagination: {
      currentPage: page,
      totalPages: Math.ceil(total / limit),
      totalOrders: total,
      hasNextPage: page < Math.ceil(total / limit),
      hasPrevPage: page > 1
    }
  };
};

// Static method to get order statistics
orderSchema.statics.getOrderStats = async function(dateFrom, dateTo) {
  const matchStage = {};
  if (dateFrom || dateTo) {
    matchStage.createdAt = {};
    if (dateFrom) matchStage.createdAt.$gte = new Date(dateFrom);
    if (dateTo) matchStage.createdAt.$lte = new Date(dateTo);
  }

  const stats = await this.aggregate([
    { $match: matchStage },
    {
      $group: {
        _id: null,
        totalOrders: { $sum: 1 },
        totalRevenue: { $sum: '$totalAmount' },
        averageOrderValue: { $avg: '$totalAmount' },
        pendingOrders: {
          $sum: { $cond: [{ $eq: ['$status', 'pending'] }, 1, 0] }
        },
        completedOrders: {
          $sum: { $cond: [{ $eq: ['$status', 'completed'] }, 1, 0] }
        }
      }
    }
  ]);

  return stats[0] || {
    totalOrders: 0,
    totalRevenue: 0,
    averageOrderValue: 0,
    pendingOrders: 0,
    completedOrders: 0
  };
};

// Instance method to update order status
orderSchema.methods.updateStatus = function(newStatus, changedBy, notes) {
  if (this.status !== newStatus) {
    this.statusHistory.push({
      status: newStatus,
      changedAt: new Date(),
      changedBy: changedBy,
      notes: notes || `Status changed to ${newStatus}`
    });
    this.status = newStatus;
  }
};

// Static method to get delivery cost based on shipping method
orderSchema.statics.getDeliveryCost = function(shippingMethod) {
  const deliveryCosts = {
    'standard': 400,  // 3 working days
    'express': 1000   // within 1 day
  };
  return deliveryCosts[shippingMethod] || 400;
};

// Static method to get estimated delivery days
orderSchema.statics.getDeliveryDays = function(shippingMethod) {
  const deliveryDays = {
    'standard': 3,  // 3 working days
    'express': 1    // 1 day
  };
  return deliveryDays[shippingMethod] || 3;
};

// Instance method to calculate totals
orderSchema.methods.calculateTotals = function() {
  this.subtotal = this.items.reduce((total, item) => total + item.totalPrice, 0);
  
  // Calculate delivery cost based on shipping method
  const shippingMethod = this.shipping?.method || 'standard';
  this.deliveryCost = this.constructor.getDeliveryCost(shippingMethod);
  
  let discountAmount = 0;
  if (this.discount.code && this.discount.amount > 0) {
    if (this.discount.type === 'percentage') {
      discountAmount = (this.subtotal * this.discount.amount) / 100;
    } else {
      discountAmount = this.discount.amount;
    }
  }
  
  this.totalAmount = this.subtotal + this.deliveryCost - discountAmount;
  
  // Ensure total amount is not negative
  if (this.totalAmount < 0) {
    this.totalAmount = 0;
  }
};

const Order = mongoose.model('Order', orderSchema);

export default Order;
